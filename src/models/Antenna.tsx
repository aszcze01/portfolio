/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import { Suspense, useEffect, useRef } from 'react'
import { useGLTF, useAnimations, OrbitControls } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import AntennaScene from '../assets/3D/antenna_anim-transformed.glb'
import { Canvas } from '@react-three/fiber'
import PostProcessingEffects from '../components/Effects'

type GLTFResult = GLTF & {
  nodes: {
    dish: THREE.Mesh
    pole: THREE.Mesh
    pivot: THREE.Mesh
  }
  materials: {}
  animations: GLTFAction[]
}

type ActionName = 'dishAction' | 'pivotAction'
interface GLTFAction extends THREE.AnimationClip {
  name: ActionName
}
// type ContextType = Record<string, React.ForwardRefExoticComponent<JSX.IntrinsicElements['mesh']>>
  
const Antenna = (props: JSX.IntrinsicElements['group']) => {

  const group = useRef<THREE.Group>(null!)

  const { nodes, animations } = useGLTF(AntennaScene) as GLTFResult
  
  const { actions, mixer } = useAnimations(animations, group);
  
  useEffect(() => {
    actions.dishAction!.play();
    actions.pivotAction!.play();
  }, [mixer]);

  const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, opacity: 0.85, transparent: true })

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <mesh name="dish" geometry={nodes.dish.geometry} material={material} position={[0.021, 4.522, 0.683]} />
        <mesh name="pole" geometry={nodes.pole.geometry} material={material} position={[0.012, 3.605, 0.005]} />
        <mesh name="pivot" geometry={nodes.pivot.geometry} material={material} position={[0.013, 4.567, 0.009]} rotation={[-1.309, 0, -1.549]} />
      </group>
    </group>
  )
}

useGLTF.preload(AntennaScene)

export default () => (
    <Canvas
        orthographic
        camera={{
            position: [0, 0, 300],
        }}
    >
        <OrbitControls
        enableZoom={false}
        minPolarAngle={Math.PI / 2}
        maxPolarAngle={Math.PI / 2}
        />
        <ambientLight intensity={0.3} />
        <directionalLight position={[0, 0, 10]} intensity={0.7} />
        <directionalLight position={[0, 0, -10]} intensity={0.7} />
        <PostProcessingEffects />
        <Suspense fallback={null}>
            <mesh scale={60} position={[0, -200, 0]} rotation={[0, -Math.PI / 5, 0]}>
                <Antenna />
            </mesh>
        </Suspense>
    </Canvas>
  );